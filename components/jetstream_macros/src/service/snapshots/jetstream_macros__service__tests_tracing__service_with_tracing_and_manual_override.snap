---
source: components/jetstream_macros/src/service/tests_tracing.rs
expression: output_str
---
pub mod echo_protocol {
    use jetstream::prelude::*;
    use std::mem;
    use super::Echo;
    const MESSAGE_ID_START: u8 = 101;
    pub const PROTOCOL_VERSION: &str = "dev.branch.jetstream.proto/NAME/VERSION-HASH";
    const DIGEST: &str = "DIGEST_HASH";
    pub const TPING: u8 = MESSAGE_ID_START + 0u8;
    pub const RPING: u8 = MESSAGE_ID_START + 0u8 + 1;
    pub const TPONG: u8 = MESSAGE_ID_START + 2u8;
    pub const RPONG: u8 = MESSAGE_ID_START + 2u8 + 1;
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Tping {
        pub message: String,
    }
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Tpong {}
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Rping(pub String);
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Rpong(pub ());
    #[derive(Debug)]
    #[repr(u8)]
    pub enum Tmessage {
        Ping(Tping) = TPING,
        Pong(Tpong) = TPONG,
    }
    impl Framer for Tmessage {
        fn byte_size(&self) -> u32 {
            match &self {
                Tmessage::Ping(msg) => msg.byte_size(),
                Tmessage::Pong(msg) => msg.byte_size(),
            }
        }
        fn message_type(&self) -> u8 {
            match self {
                Tmessage::Ping(_) => TPING,
                Tmessage::Pong(_) => TPONG,
            }
        }
        fn encode<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
            match &self {
                Tmessage::Ping(msg) => msg.encode(writer)?,
                Tmessage::Pong(msg) => msg.encode(writer)?,
            }
            Ok(())
        }
        fn decode<R: std::io::Read>(
            reader: &mut R,
            ty: u8,
        ) -> std::io::Result<Tmessage> {
            match ty {
                TPING => Ok(Tmessage::Ping(WireFormat::decode(reader)?)),
                TPONG => Ok(Tmessage::Pong(WireFormat::decode(reader)?)),
                _ => {
                    Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("unknown message type: {}", ty),
                        ),
                    )
                }
            }
        }
    }
    #[derive(Debug)]
    #[repr(u8)]
    pub enum Rmessage {
        Ping(Rping) = RPING,
        Pong(Rpong) = RPONG,
    }
    impl Framer for Rmessage {
        fn byte_size(&self) -> u32 {
            match &self {
                Rmessage::Ping(msg) => msg.byte_size(),
                Rmessage::Pong(msg) => msg.byte_size(),
            }
        }
        fn message_type(&self) -> u8 {
            match self {
                Rmessage::Ping(_) => RPING,
                Rmessage::Pong(_) => RPONG,
            }
        }
        fn encode<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
            match &self {
                Rmessage::Ping(msg) => msg.encode(writer)?,
                Rmessage::Pong(msg) => msg.encode(writer)?,
            }
            Ok(())
        }
        fn decode<R: std::io::Read>(
            reader: &mut R,
            ty: u8,
        ) -> std::io::Result<Rmessage> {
            match ty {
                RPING => Ok(Rmessage::Ping(WireFormat::decode(reader)?)),
                RPONG => Ok(Rmessage::Pong(WireFormat::decode(reader)?)),
                _ => {
                    Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("unknown message type: {}", ty),
                        ),
                    )
                }
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EchoService<T: Echo> {
        pub inner: T,
    }
    impl<T> Protocol for EchoService<T>
    where
        T: Echo + Send + Sync + Sized,
    {
        type Request = Tmessage;
        type Response = Rmessage;
        type Error = Error;
        const VERSION: &'static str = PROTOCOL_VERSION;
        fn rpc(
            &mut self,
            ctx: Context,
            frame: Frame<<Self as Protocol>::Request>,
        ) -> impl ::core::future::Future<
            Output = Result<Frame<<Self as Protocol>::Response>, Self::Error>,
        > + Send + Sync {
            Box::pin(async move {
                let _span = tracing::debug_span!(
                    "rpc_server", service = stringify!(Echo), tag = frame.tag
                );
                let _enter = _span.enter();
                let req: <Self as Protocol>::Request = frame.msg;
                let res: Result<<Self as Protocol>::Response, Self::Error> = match req {
                    Tmessage::Ping(msg) => {
                        let result = self.ping(msg.message).await?;
                        let ret = Rping(result);
                        Ok(Rmessage::Ping(ret))
                    }
                    Tmessage::Pong(msg) => {
                        let result = self.pong().await?;
                        let ret = Rpong(result);
                        Ok(Rmessage::Pong(ret))
                    }
                };
                let rframe: Frame<<Self as Protocol>::Response> = Frame::from((
                    frame.tag,
                    res?,
                ));
                Ok(rframe)
            })
        }
    }
    impl<T> Echo for EchoService<T>
    where
        T: Echo + Send + Sync + Sized,
    {
        #[instrument(level = "trace")]
        async fn ping(&mut self, message: String) -> Result<String, std::io::Error> {
            self.inner.ping(message).await
        }
        #[tracing::instrument(skip(self))]
        async fn pong(&mut self) -> Result<(), std::io::Error> {
            self.inner.pong().await
        }
    }
    pub struct EchoChannel<'a> {
        pub inner: Box<&'a mut dyn ClientTransport<Self>>,
    }
    impl<'a> Protocol for EchoChannel<'a> {
        type Request = Tmessage;
        type Response = Rmessage;
        type Error = Error;
        const VERSION: &'static str = PROTOCOL_VERSION;
        fn rpc(
            &mut self,
            _ctx: Context,
            frame: Frame<<Self as Protocol>::Request>,
        ) -> impl ::core::future::Future<
            Output = Result<Frame<<Self as Protocol>::Response>, Self::Error>,
        > + Send + Sync {
            use futures::{SinkExt, StreamExt};
            Box::pin(async move {
                let _span = tracing::debug_span!(
                    "rpc_client", service = stringify!(Echo), tag = frame.tag
                );
                let _enter = _span.enter();
                self.inner.send(frame).await?;
                let frame = self.inner.next().await.unwrap()?;
                Ok(frame)
            })
        }
    }
    lazy_static::lazy_static! {
        static ref ECHO_TAG : std::sync::atomic::AtomicU16 =
        std::sync::atomic::AtomicU16::new(0);
    }
    impl<'a> Echo for EchoChannel<'a> {
        #[instrument(level = "trace")]
        async fn ping(&mut self, message: String) -> Result<String, std::io::Error> {
            let tag = ECHO_TAG.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
            let req = Tmessage::Ping(Tping { message });
            let tframe = Frame::from((tag, req));
            let context = Context::default();
            let rframe = self.rpc(context, tframe).await?;
            let rmsg = rframe.msg;
            match rmsg {
                Rmessage::Ping(msg) => Ok(msg.0),
                _ => Err(Error::InvalidResponse),
            }
        }
        #[tracing::instrument(skip(self))]
        async fn pong(&mut self) -> Result<(), std::io::Error> {
            let tag = ECHO_TAG.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
            let req = Tmessage::Pong(Tpong {});
            let tframe = Frame::from((tag, req));
            let context = Context::default();
            let rframe = self.rpc(context, tframe).await?;
            let rmsg = rframe.msg;
            match rmsg {
                Rmessage::Pong(msg) => Ok(msg.0),
                _ => Err(Error::InvalidResponse),
            }
        }
    }
}
#[jetstream::prelude::make(Send+Sync)]
pub trait Echo {
    async fn ping(&mut self, message: String) -> Result<String, std::io::Error>;
    async fn pong(&mut self) -> Result<(), std::io::Error>;
}
