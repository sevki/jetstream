---
source: components/jetstream_macros/src/service/tests_tracing.rs
expression: output_str
---
pub mod echo_protocol {
    use jetstream::prelude::*;
    use std::mem;
    use super::Echo;
    const MESSAGE_ID_START: u8 = 102;
    /// Error response message type constant
    pub const RERROR: u8 = jetstream::prelude::RJETSTREAMERROR;
    /// Version request message type constant
    pub const TVERSION: u8 = jetstream::prelude::TVERSION;
    /// Version response message type constant
    pub const RVERSION: u8 = jetstream::prelude::RVERSION;
    /// Protocol name â€” used for routing
    pub const PROTOCOL_NAME: &str = concat!("rs.jetstream.proto/", "echo");
    /// Protocol version string constructed from the generated crate's version
    pub const PROTOCOL_VERSION: &str = concat!(
        "rs.jetstream.proto/", "echo", "/", env!("CARGO_PKG_VERSION_MAJOR"), ".",
        env!("CARGO_PKG_VERSION_MINOR"), ".", env!("CARGO_PKG_VERSION_PATCH"), "+",
        "96eeb151"
    );
    const DIGEST: &str = "DIGEST_HASH";
    pub const TPING: u8 = MESSAGE_ID_START + 0u8;
    pub const RPING: u8 = MESSAGE_ID_START + 0u8 + 1;
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Tping {
        pub message: String,
    }
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Rping(pub String);
    #[derive(Debug)]
    #[repr(u8)]
    pub enum Tmessage {
        Ping(Tping) = TPING,
        Version(jetstream::prelude::Tversion) = TVERSION,
    }
    impl Framer for Tmessage {
        fn byte_size(&self) -> u32 {
            match &self {
                Tmessage::Ping(msg) => msg.byte_size(),
                Tmessage::Version(v) => v.byte_size(),
            }
        }
        fn message_type(&self) -> u8 {
            match self {
                Tmessage::Ping(_) => TPING,
                Tmessage::Version(_) => TVERSION,
            }
        }
        fn encode<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
            match &self {
                Tmessage::Ping(msg) => msg.encode(writer)?,
                Tmessage::Version(v) => v.encode(writer)?,
            }
            Ok(())
        }
        fn decode<R: std::io::Read>(
            reader: &mut R,
            ty: u8,
        ) -> std::io::Result<Tmessage> {
            match ty {
                TPING => Ok(Tmessage::Ping(WireFormat::decode(reader)?)),
                TVERSION => Ok(Tmessage::Version(WireFormat::decode(reader)?)),
                _ => {
                    Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("unknown message type: {}", ty),
                        ),
                    )
                }
            }
        }
    }
    #[derive(Debug)]
    #[repr(u8)]
    pub enum Rmessage {
        Ping(Rping) = RPING,
        Error(jetstream::prelude::Error) = RERROR,
        Version(jetstream::prelude::Rversion) = RVERSION,
    }
    impl Framer for Rmessage {
        fn byte_size(&self) -> u32 {
            match &self {
                Rmessage::Ping(msg) => msg.byte_size(),
                Rmessage::Error(err) => err.byte_size(),
                Rmessage::Version(v) => v.byte_size(),
            }
        }
        fn message_type(&self) -> u8 {
            match self {
                Rmessage::Ping(_) => RPING,
                Rmessage::Error(_) => RERROR,
                Rmessage::Version(_) => RVERSION,
            }
        }
        fn encode<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
            match &self {
                Rmessage::Ping(msg) => msg.encode(writer)?,
                Rmessage::Error(err) => err.encode(writer)?,
                Rmessage::Version(v) => v.encode(writer)?,
            }
            Ok(())
        }
        fn decode<R: std::io::Read>(
            reader: &mut R,
            ty: u8,
        ) -> std::io::Result<Rmessage> {
            match ty {
                RPING => Ok(Rmessage::Ping(WireFormat::decode(reader)?)),
                RERROR => Ok(Rmessage::Error(WireFormat::decode(reader)?)),
                RVERSION => Ok(Rmessage::Version(WireFormat::decode(reader)?)),
                _ => {
                    Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("unknown message type: {}", ty),
                        ),
                    )
                }
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EchoService<T: Echo> {
        pub inner: T,
    }
    impl<T> Protocol for EchoService<T>
    where
        T: Echo + Send + Sync + Sized,
    {
        type Request = Tmessage;
        type Response = Rmessage;
        type Error = Error;
        const VERSION: &'static str = PROTOCOL_VERSION;
        const NAME: &'static str = PROTOCOL_NAME;
    }
    impl<T> Server for EchoService<T>
    where
        T: Echo + Send + Sync + Sized,
    {
        fn rpc(
            &mut self,
            ctx: Context,
            frame: Frame<<Self as Protocol>::Request>,
        ) -> impl ::core::future::Future<
            Output = Result<Frame<<Self as Protocol>::Response>>,
        > + Send + Sync {
            Box::pin(async move {
                let req: <Self as Protocol>::Request = frame.msg;
                let res: std::result::Result<
                    <Self as Protocol>::Response,
                    Self::Error,
                > = match req {
                    Tmessage::Version(tversion) => {
                        use std::str::FromStr;
                        let client_version = jetstream::prelude::Version::from_str(
                                &tversion.version,
                            )
                            .map_err(|e| Error::new(e))?;
                        match Self::version(client_version) {
                            Ok(negotiated) => {
                                Ok(
                                    Rmessage::Version(jetstream::prelude::Rversion {
                                        msize: tversion.msize,
                                        version: negotiated.to_string(),
                                    }),
                                )
                            }
                            Err(_) => {
                                Ok(
                                    Rmessage::Version(jetstream::prelude::Rversion {
                                        msize: 0,
                                        version: "unknown".to_string(),
                                    }),
                                )
                            }
                        }
                    }
                    Tmessage::Ping(msg) => {
                        match self.ping(msg.message).await {
                            Ok(result) => {
                                let ret = Rping(result);
                                Ok(Rmessage::Ping(ret))
                            }
                            Err(err) => Err(err.into()),
                        }
                    }
                };
                let response = match res {
                    Ok(msg) => msg,
                    Err(err) => Rmessage::Error(err),
                };
                let rframe: Frame<<Self as Protocol>::Response> = Frame::from((
                    frame.tag,
                    response,
                ));
                Ok(rframe)
            })
        }
    }
    impl<T> Echo for EchoService<T>
    where
        T: Echo + Send + Sync + Sized,
    {
        #[instrument(
            name = "echo_ping",
            skip(self),
            fields(message_len = message.len()),
            level = "debug"
        )]
        async fn ping(&mut self, message: String) -> Result<String, std::io::Error> {
            self.inner.ping(message).await
        }
    }
    pub struct EchoChannel {
        mux: Mux<Self>,
    }
    impl EchoChannel {
        pub fn new(
            max_concurrent_requests: u16,
            inner: Box<dyn ClientTransport<Self>>,
        ) -> Self {
            Self {
                mux: Mux::new(max_concurrent_requests, inner),
            }
        }
        /// Perform Tversion/Rversion handshake with the server.
        /// Must be called after `new()` and before any RPC calls.
        pub async fn negotiate_version(
            &self,
            msize: u32,
        ) -> std::result::Result<jetstream::prelude::Rversion, Error> {
            let req = Tmessage::Version(jetstream::prelude::Tversion {
                msize,
                version: PROTOCOL_VERSION.to_string(),
            });
            let context = Context::default();
            let rframe = self.mux.rpc(context, req).await.await?;
            match rframe.msg {
                Rmessage::Version(rversion) => {
                    if rversion.version == "unknown" {
                        Err(Error::new("server rejected version negotiation"))
                    } else {
                        Ok(rversion)
                    }
                }
                Rmessage::Error(err) => Err(err),
                _ => Err(Error::new("unexpected response to Tversion")),
            }
        }
    }
    impl Protocol for EchoChannel {
        type Request = Tmessage;
        type Response = Rmessage;
        type Error = Error;
        const VERSION: &'static str = PROTOCOL_VERSION;
        const NAME: &'static str = PROTOCOL_NAME;
    }
    impl Echo for EchoChannel {
        #[instrument(
            name = "echo_ping",
            skip(self),
            fields(message_len = message.len()),
            level = "debug"
        )]
        async fn ping(&mut self, message: String) -> Result<String, std::io::Error> {
            let req = Tmessage::Ping(Tping { message });
            let context = Context::default();
            let rframe = self.mux.rpc(context, req).await.await?;
            let rmsg = rframe.msg;
            match rmsg {
                Rmessage::Ping(msg) => Ok(msg.0),
                Rmessage::Error(err) => Err(err),
                _ => Err(Error::new("invalid reposne")),
            }
        }
    }
}
#[jetstream::prelude::make(Send+Sync)]
pub trait Echo {
    async fn ping(&mut self, message: String) -> Result<String, std::io::Error>;
}
