---
source: components/jetstream_macros/src/service/tests_tracing.rs
expression: output_str
---
pub mod complexservice_protocol {
    use jetstream::prelude::*;
    use std::mem;
    use super::ComplexService;
    const MESSAGE_ID_START: u8 = 101;
    /// Error response message type constant
    pub const RERROR: u8 = 100;
    pub const PROTOCOL_VERSION: &str = "dev.branch.jetstream.proto/NAME/VERSION-HASH";
    const DIGEST: &str = "DIGEST_HASH";
    pub const TLOGIN: u8 = MESSAGE_ID_START + 0u8;
    pub const RLOGIN: u8 = MESSAGE_ID_START + 0u8 + 1;
    pub const TLOGOUT: u8 = MESSAGE_ID_START + 2u8;
    pub const RLOGOUT: u8 = MESSAGE_ID_START + 2u8 + 1;
    pub const TGET_STATUS: u8 = MESSAGE_ID_START + 4u8;
    pub const RGET_STATUS: u8 = MESSAGE_ID_START + 4u8 + 1;
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Tlogin {
        pub username: String,
        pub password: String,
    }
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Tlogout {}
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Tget_status {}
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Rlogin(pub String);
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Rlogout(pub ());
    #[allow(non_camel_case_types)]
    #[derive(Debug, JetStreamWireFormat)]
    pub struct Rget_status(pub String);
    #[derive(Debug)]
    #[repr(u8)]
    pub enum Tmessage {
        Login(Tlogin) = TLOGIN,
        Logout(Tlogout) = TLOGOUT,
        GetStatus(Tget_status) = TGET_STATUS,
    }
    impl Framer for Tmessage {
        fn byte_size(&self) -> u32 {
            match &self {
                Tmessage::Login(msg) => msg.byte_size(),
                Tmessage::Logout(msg) => msg.byte_size(),
                Tmessage::GetStatus(msg) => msg.byte_size(),
            }
        }
        fn message_type(&self) -> u8 {
            match self {
                Tmessage::Login(_) => TLOGIN,
                Tmessage::Logout(_) => TLOGOUT,
                Tmessage::GetStatus(_) => TGET_STATUS,
            }
        }
        fn encode<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
            match &self {
                Tmessage::Login(msg) => msg.encode(writer)?,
                Tmessage::Logout(msg) => msg.encode(writer)?,
                Tmessage::GetStatus(msg) => msg.encode(writer)?,
            }
            Ok(())
        }
        fn decode<R: std::io::Read>(
            reader: &mut R,
            ty: u8,
        ) -> std::io::Result<Tmessage> {
            match ty {
                TLOGIN => Ok(Tmessage::Login(WireFormat::decode(reader)?)),
                TLOGOUT => Ok(Tmessage::Logout(WireFormat::decode(reader)?)),
                TGET_STATUS => Ok(Tmessage::GetStatus(WireFormat::decode(reader)?)),
                _ => {
                    Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("unknown message type: {}", ty),
                        ),
                    )
                }
            }
        }
    }
    #[derive(Debug)]
    #[repr(u8)]
    pub enum Rmessage {
        Login(Rlogin) = RLOGIN,
        Logout(Rlogout) = RLOGOUT,
        GetStatus(Rget_status) = RGET_STATUS,
        Error(jetstream::prelude::Error) = RERROR,
    }
    impl Framer for Rmessage {
        fn byte_size(&self) -> u32 {
            match &self {
                Rmessage::Login(msg) => msg.byte_size(),
                Rmessage::Logout(msg) => msg.byte_size(),
                Rmessage::GetStatus(msg) => msg.byte_size(),
                Rmessage::Error(err) => err.byte_size(),
            }
        }
        fn message_type(&self) -> u8 {
            match self {
                Rmessage::Login(_) => RLOGIN,
                Rmessage::Logout(_) => RLOGOUT,
                Rmessage::GetStatus(_) => RGET_STATUS,
                Rmessage::Error(_) => RERROR,
            }
        }
        fn encode<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
            match &self {
                Rmessage::Login(msg) => msg.encode(writer)?,
                Rmessage::Logout(msg) => msg.encode(writer)?,
                Rmessage::GetStatus(msg) => msg.encode(writer)?,
                Rmessage::Error(err) => err.encode(writer)?,
            }
            Ok(())
        }
        fn decode<R: std::io::Read>(
            reader: &mut R,
            ty: u8,
        ) -> std::io::Result<Rmessage> {
            match ty {
                RLOGIN => Ok(Rmessage::Login(WireFormat::decode(reader)?)),
                RLOGOUT => Ok(Rmessage::Logout(WireFormat::decode(reader)?)),
                RGET_STATUS => Ok(Rmessage::GetStatus(WireFormat::decode(reader)?)),
                RERROR => Ok(Rmessage::Error(WireFormat::decode(reader)?)),
                _ => {
                    Err(
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("unknown message type: {}", ty),
                        ),
                    )
                }
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ComplexServiceService<T: ComplexService> {
        pub inner: T,
    }
    impl<T> Protocol for ComplexServiceService<T>
    where
        T: ComplexService + Send + Sync + Sized,
    {
        type Request = Tmessage;
        type Response = Rmessage;
        type Error = Error;
        const VERSION: &'static str = PROTOCOL_VERSION;
    }
    impl<T> Server for ComplexServiceService<T>
    where
        T: ComplexService + Send + Sync + Sized,
    {
        fn rpc(
            &mut self,
            ctx: Context,
            frame: Frame<<Self as Protocol>::Request>,
        ) -> impl ::core::future::Future<
            Output = Result<Frame<<Self as Protocol>::Response>>,
        > + Send + Sync {
            Box::pin(async move {
                let _span = tracing::debug_span!(
                    "rpc_server", service = stringify!(ComplexService), tag = frame.tag
                );
                let _enter = _span.enter();
                let req: <Self as Protocol>::Request = frame.msg;
                let res: std::result::Result<
                    <Self as Protocol>::Response,
                    Self::Error,
                > = match req {
                    Tmessage::Login(msg) => {
                        match self.login(msg.username, msg.password).await {
                            Ok(result) => {
                                let ret = Rlogin(result);
                                Ok(Rmessage::Login(ret))
                            }
                            Err(err) => Err(err.into()),
                        }
                    }
                    Tmessage::Logout(msg) => {
                        match self.logout().await {
                            Ok(result) => {
                                let ret = Rlogout(result);
                                Ok(Rmessage::Logout(ret))
                            }
                            Err(err) => Err(err.into()),
                        }
                    }
                    Tmessage::GetStatus(msg) => {
                        match self.get_status().await {
                            Ok(result) => {
                                let ret = Rget_status(result);
                                Ok(Rmessage::GetStatus(ret))
                            }
                            Err(err) => Err(err.into()),
                        }
                    }
                };
                let response = match res {
                    Ok(msg) => msg,
                    Err(err) => Rmessage::Error(err),
                };
                let rframe: Frame<<Self as Protocol>::Response> = Frame::from((
                    frame.tag,
                    response,
                ));
                Ok(rframe)
            })
        }
    }
    impl<T> ComplexService for ComplexServiceService<T>
    where
        T: ComplexService + Send + Sync + Sized,
    {
        #[instrument(skip(self, password))]
        async fn login(
            &mut self,
            username: String,
            password: String,
        ) -> Result<String, std::io::Error> {
            self.inner.login(username, password).await
        }
        #[tracing::instrument(skip(self))]
        async fn logout(&mut self) -> Result<(), std::io::Error> {
            self.inner.logout().await
        }
        #[instrument(level = "debug")]
        async fn get_status(&self) -> Result<String, std::io::Error> {
            self.inner.get_status().await
        }
    }
    pub struct ComplexServiceChannel {
        mux: Mux<Self>,
    }
    impl ComplexServiceChannel {
        pub fn new(
            max_concurrent_requests: u16,
            inner: Box<dyn ClientTransport<Self>>,
        ) -> Self {
            Self {
                mux: Mux::new(max_concurrent_requests, inner),
            }
        }
    }
    impl Protocol for ComplexServiceChannel {
        type Request = Tmessage;
        type Response = Rmessage;
        type Error = Error;
        const VERSION: &'static str = PROTOCOL_VERSION;
    }
    impl ComplexService for ComplexServiceChannel {
        #[instrument(skip(self, password))]
        async fn login(
            &mut self,
            username: String,
            password: String,
        ) -> Result<String, std::io::Error> {
            let req = Tmessage::Login(Tlogin { username, password });
            let context = Context::default();
            let rframe = self.mux.rpc(context, req).await.await?;
            let rmsg = rframe.msg;
            match rmsg {
                Rmessage::Login(msg) => Ok(msg.0),
                Rmessage::Error(err) => Err(err),
                _ => Err(Error::InvalidResponse),
            }
        }
        #[tracing::instrument(skip(self))]
        async fn logout(&mut self) -> Result<(), std::io::Error> {
            let req = Tmessage::Logout(Tlogout {});
            let context = Context::default();
            let rframe = self.mux.rpc(context, req).await.await?;
            let rmsg = rframe.msg;
            match rmsg {
                Rmessage::Logout(msg) => Ok(msg.0),
                Rmessage::Error(err) => Err(err),
                _ => Err(Error::InvalidResponse),
            }
        }
        #[instrument(level = "debug")]
        async fn get_status(&self) -> Result<String, std::io::Error> {
            let req = Tmessage::GetStatus(Tget_status {});
            let context = Context::default();
            let rframe = self.mux.rpc(context, req).await.await?;
            let rmsg = rframe.msg;
            match rmsg {
                Rmessage::GetStatus(msg) => Ok(msg.0),
                Rmessage::Error(err) => Err(err),
                _ => Err(Error::InvalidResponse),
            }
        }
    }
}
#[jetstream::prelude::make(Send+Sync)]
pub trait ComplexService {
    async fn login(
        &mut self,
        username: String,
        password: String,
    ) -> Result<String, std::io::Error>;
    async fn logout(&mut self) -> Result<(), std::io::Error>;
    async fn get_status(&self) -> Result<String, std::io::Error>;
}
